# CyberChat - Intelligent Cybersecurity Assistant

#### Video Demo: <URL_YOUTUBE>

#### Description:

## Project Overview

CyberChat is an advanced interactive chatbot specialized in cybersecurity, developed as a final project for CS50's Introduction to Programming with Python. This system uses a RAG (Retrieval-Augmented Generation) architecture to provide accurate and contextual answers to cybersecurity questions by leveraging a structured knowledge base.

The project combines several modern technologies: natural language processing with Hugging Face models, semantic search via ChromaDB, and an intuitive user interface built with Streamlit. The main objective is to democratize access to cybersecurity knowledge by providing clear, technical, and sourced responses.

## Architecture and Functionality

The system operates in three distinct phases. First, during initialization, cybersecurity reference documents are processed and transformed into vector embeddings stored in ChromaDB. This knowledge base enables fast and relevant semantic search.

Second, when a user asks a question, the system searches for the most relevant documents in the vector database using cosine similarity. Documents are ranked by relevance score, ensuring that only the most useful context is utilized.

Third, the retrieved documents are combined with the user's question in a structured prompt that is then sent to a language model via the Hugging Face API. The system tries several free models (Qwen, Llama, Mistral, Phi) to guarantee maximum availability.

## Detailed File Structure

### project.py

This file serves as the main entry point of the application. It contains the `main()` function that launches the Streamlit interface and orchestrates user interactions. The file also implements three essential functions required by CS50:

**validate_input(text)**: This function verifies that user input is valid, meaning non-empty and containing at least one non-whitespace character. It returns a boolean indicating whether the input can be processed. This validation is crucial to avoid empty queries that would waste API resources.

**detect_cyber_topic(message)**: This function analyzes the user's message to determine if it concerns cybersecurity. It uses a list of keywords (cyber, security, hack, malware, phishing, etc.) and checks for their presence in the message. This detection helps guide responses and warn users if their question falls outside the chatbot's domain of expertise.

**format_response(response)**: This function cleans and formats the response generated by the language model. It removes excess whitespace, handles cases where the response is empty or None, and ensures the response is presentable to the user. It also adds appropriate error messages when necessary.

The `main()` function creates the Streamlit interface with two main sections: a section to generate or update the knowledge base, and a section to ask questions and receive answers with their sources.

### test_project.py

This file contains comprehensive unit tests for the three main functions, in accordance with CS50 requirements. Each function is tested with multiple test cases covering normal scenarios and edge cases.

**test_validate_input()**: Tests validation with valid strings (normal text, complete sentences), invalid strings (empty, whitespace only), and edge cases (single character, special characters).

**test_detect_cyber_topic()**: Verifies keyword detection with different variations (lowercase, uppercase, accents), tests false positives (questions unrelated to cybersecurity), and validates that multiple keywords can be detected.

**test_format_response()**: Tests formatting with normal responses, responses containing excess whitespace, empty responses, and None values. Also verifies that appropriate error messages are generated.

Using pytest allows easy test execution with the `pytest test_project.py` command, ensuring code reliability.

### modules/chatbot_engine.py

This module contains the core logic of the RAG system. It manages the connection to the Hugging Face API, searches in ChromaDB, and generates responses. The `initialize_client()` function establishes the connection with several fallback models to guarantee service availability.

The `answer_question(query_text, k=3)` function implements the complete RAG pipeline: it converts the question into an embedding, searches for the k most similar documents in ChromaDB, constructs a contextual prompt, and generates a response using a language model. It returns both the response and the list of sources with their relevance scores.

The module uses detailed logging to facilitate debugging and monitoring. It also handles errors robustly, trying multiple models if the first one is unavailable.

### modules/data_store.py

This module is responsible for creating and updating the vector knowledge base. It reads PDF documents from the `data/` folder, splits them into optimal chunks for semantic search, generates embeddings with the Sentence Transformers model, and stores them in ChromaDB.

The function uses intelligent chunking strategies with overlap to preserve context between segments. This ensures that no important information is lost during document segmentation.

### requirements.txt

Lists all necessary Python dependencies:
- **streamlit**: Framework for web user interface
- **langchain-community**: Tools for RAG and document management
- **chromadb**: Vector database for semantic search
- **huggingface-hub**: Client to access Hugging Face models
- **sentence-transformers**: Quality embedding generation
- **python-dotenv**: Secure environment variable management
- **pytest**: Unit testing framework

## Design Choices and Justifications

**RAG architecture rather than fine-tuning**: I chose a RAG approach because it allows using pre-trained models without requiring costly fine-tuning. This makes the system more flexible and easy to update with new information by simply adding documents.

**ChromaDB for vector storage**: ChromaDB was selected for its ease of use, performance, and local operation without requiring an external server. This makes the project more accessible and easy to deploy.

**Streamlit for the interface**: Streamlit enables rapid creation of a modern and responsive user interface with very little code. Its interactive widget system is perfect for a chatbot.

**Model fallback system**: Implementing a system that tries multiple models guarantees service availability even if some Hugging Face models are temporarily unavailable. This significantly improves system robustness.

**Strict input validation**: User input validation avoids unnecessary requests and protects against exploitation attempts. This is a good security practice, particularly appropriate for a cybersecurity chatbot.

## Installation and Usage

To install the project:
```bash
pip install -r requirements.txt
```

Configuration:
1. Create a `.env` file with your Hugging Face API key
2. Place your PDF documents in the `data/` folder
3. Launch the application: `streamlit run project.py`

For tests: `pytest test_project.py`

## Future Improvements

Several improvements could be made to the project: adding persistent conversation history, implementing a user feedback system to improve responses, multilingual support, and integrating real-time sources via web scraping for the latest cybersecurity news.

The project could also benefit from a voice interface for accessibility, a proactive recommendation system based on frequently asked questions, and a conversation export feature to PDF for future reference.

## Conclusion

CyberChat demonstrates the practical application of concepts learned in CS50P: file manipulation, error handling, unit testing, use of external libraries, and creation of a complete and functional application. This project illustrates how Python programming can solve real-world problems by making cybersecurity expertise accessible to everyone.

---

**Author**: Soumia Badaoui  
**Course**: CS50's Introduction to Programming with Python  
**Date**: 30/11/2025 
**GitHub**: https://github.com/Soumayabd-IT/CyberChat